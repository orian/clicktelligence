<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Branch History Graph - Clicktelligence</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        header {
            background: #252526;
            padding: 0.5rem 2rem;
            border-bottom: 1px solid #3e3e42;
        }
        h1 {
            font-size: 1.2rem;
            color: #569cd6;
        }
        .container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        .legend {
            width: 250px;
            background: #252526;
            border-right: 1px solid #3e3e42;
            padding: 1rem;
            overflow-y: auto;
        }
        .legend-title {
            font-size: 14px;
            font-weight: bold;
            color: #4ec9b0;
            margin-bottom: 1rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 12px;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #3e3e42;
        }
        .graph-container {
            flex: 1;
            overflow: auto;
            position: relative;
        }
        svg {
            display: block;
        }
        .version-node {
            cursor: pointer;
            transition: all 0.2s;
        }
        .version-node:hover circle {
            stroke-width: 3px;
            filter: brightness(1.3);
        }
        .version-node text {
            pointer-events: none;
            user-select: none;
        }
        .collapsed-node {
            cursor: pointer;
        }
        .collapsed-node:hover circle {
            filter: brightness(1.3);
        }
        .collapsed-node text {
            pointer-events: none;
            user-select: none;
        }
        .branch-line {
            fill: none;
            stroke-width: 2;
            opacity: 0.3;
        }
        .edge {
            fill: none;
            stroke: #858585;
            stroke-width: 2;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.active {
            display: flex;
        }
        .modal-content {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal-header {
            font-size: 1.2rem;
            color: #569cd6;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-close {
            background: transparent;
            border: none;
            color: #d4d4d4;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
        }
        .modal-close:hover {
            color: #f48771;
        }
        .modal-section {
            margin-bottom: 1rem;
        }
        .modal-label {
            color: #858585;
            font-size: 12px;
            margin-bottom: 0.3rem;
        }
        .modal-value {
            color: #d4d4d4;
            font-size: 14px;
        }
        .version-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
        }
        .controls {
            padding: 1rem;
            background: #252526;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .controls label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 12px;
            cursor: pointer;
        }
        .controls input[type="checkbox"] {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <header>
        <h1>Branch History Graph</h1>
        <p style="color: #858585; font-size: 11px; margin: 0;">Query Optimization Timeline</p>
    </header>

    <div class="controls">
        <label>
            <input type="checkbox" id="collapseToggle" onchange="toggleCollapse()">
            Collapse (show only heads & branch points)
        </label>
    </div>

    <div class="container">
        <div class="legend">
            <div class="legend-title">Branches</div>
            <div id="legendItems"></div>
        </div>

        <div class="graph-container">
            <svg id="graph"></svg>
        </div>
    </div>

    <div class="modal" id="versionModal">
        <div class="modal-content">
            <div class="modal-header">
                <span id="modalTitle">Version Details</span>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div id="modalBody"></div>
        </div>
    </div>

    <script>
        // Test data structure
        const testData = {
            versions: [
                // Main branch: v0 through v10
                { id: 0, branch: 'main', parentId: null },
                { id: 1, branch: 'main', parentId: 0 },
                { id: 2, branch: 'main', parentId: 1 },
                { id: 3, branch: 'main', parentId: 2 },
                { id: 4, branch: 'main', parentId: 3 },
                { id: 5, branch: 'main', parentId: 4 },
                { id: 6, branch: 'main', parentId: 5 },
                { id: 7, branch: 'main', parentId: 6 },
                { id: 8, branch: 'main', parentId: 7 },
                { id: 9, branch: 'main', parentId: 8 },
                { id: 10, branch: 'main', parentId: 9 },
                { id: 17, branch: 'main', parentId: 10 },
                { id: 18, branch: 'main', parentId: 17 },

                // Test branch: branches from main v2, creates v11
                { id: 11, branch: 'test', parentId: 2 },

                // Chill branch: branches from main v4, creates v12, v13, v14
                { id: 12, branch: 'chill', parentId: 4 },
                { id: 13, branch: 'chill', parentId: 12 },
                { id: 14, branch: 'chill', parentId: 13 },

                // Chillier branch: branches from chill v12, creates v15
                { id: 15, branch: 'chillier', parentId: 12 },

                // Experiment branch: branches from main v8, creates v16
                { id: 16, branch: 'experiment', parentId: 8 }
            ],
            branches: {
                'main': { name: 'main', color: '#569cd6' },
                'test': { name: 'test', color: '#4ec9b0' },
                'chill': { name: 'chill', color: '#dcdcaa' },
                'chillier': { name: 'chillier', color: '#ce9178' },
                'experiment': { name: 'experiment', color: '#c586c0' }
            }
        };

        // Graph configuration
        const config = {
            nodeRadius: 8,
            verticalSpacing: 30,
            horizontalSpacing: 50,
            branchPointSpacing: 20, // Extra spacing when branching
            padding: { top: 40, right: 40, bottom: 40, left: 40 }
        };

        // Build graph data structure
        function buildGraph(data) {
            const graph = {
                nodes: [],
                edges: [],
                layers: []
            };

            // Create node map
            const nodeMap = new Map();
            data.versions.forEach(v => {
                nodeMap.set(v.id, {
                    ...v,
                    children: [],
                    x: 0,
                    y: 0,
                    layer: 0
                });
            });

            // Build parent-child relationships
            data.versions.forEach(v => {
                if (v.parentId !== null) {
                    const parent = nodeMap.get(v.parentId);
                    if (parent) {
                        parent.children.push(v.id);
                        graph.edges.push({ from: v.parentId, to: v.id });
                    }
                }
            });

            // Assign layers (vertical position based on distance from root)
            function assignLayers(nodeId, layer) {
                const node = nodeMap.get(nodeId);
                node.layer = Math.max(node.layer, layer);
                node.children.forEach(childId => assignLayers(childId, layer + 1));
            }
            assignLayers(0, 0);

            // Group nodes by layer
            const maxLayer = Math.max(...Array.from(nodeMap.values()).map(n => n.layer));
            for (let i = 0; i <= maxLayer; i++) {
                graph.layers[i] = Array.from(nodeMap.values()).filter(n => n.layer === i);
            }

            // Assign horizontal positions (branch lanes) with lane packing
            // First, count versions per branch and get layer ranges
            const branchInfo = new Map();
            nodeMap.forEach(node => {
                if (!branchInfo.has(node.branch)) {
                    branchInfo.set(node.branch, {
                        count: 0,
                        minLayer: Infinity,
                        maxLayer: -Infinity,
                        nodes: []
                    });
                }
                const info = branchInfo.get(node.branch);
                info.count++;
                info.minLayer = Math.min(info.minLayer, node.layer);
                info.maxLayer = Math.max(info.maxLayer, node.layer);
                info.nodes.push(node);
            });

            // Sort branches by version count (longest first)
            const sortedBranches = Array.from(branchInfo.entries())
                .sort((a, b) => b[1].count - a[1].count) // Sort descending by count
                .map(entry => ({ name: entry[0], ...entry[1] }));

            // Track which lanes are occupied at each layer
            const laneOccupancy = new Map(); // Map<layer, Set<lane>>

            function isLaneAvailable(lane, minLayer, maxLayer) {
                for (let layer = minLayer; layer <= maxLayer; layer++) {
                    if (laneOccupancy.has(layer) && laneOccupancy.get(layer).has(lane)) {
                        return false;
                    }
                }
                return true;
            }

            function occupyLane(lane, minLayer, maxLayer) {
                for (let layer = minLayer; layer <= maxLayer; layer++) {
                    if (!laneOccupancy.has(layer)) {
                        laneOccupancy.set(layer, new Set());
                    }
                    laneOccupancy.get(layer).add(lane);
                }
            }

            // Assign lanes to branches (pack into leftmost available)
            const branchLanes = new Map();
            let maxLane = -1;

            sortedBranches.forEach(branchData => {
                // Find leftmost available lane for this branch
                let assignedLane = 0;
                while (!isLaneAvailable(assignedLane, branchData.minLayer, branchData.maxLayer)) {
                    assignedLane++;
                }

                // Assign this lane to the branch
                branchLanes.set(branchData.name, assignedLane);
                occupyLane(assignedLane, branchData.minLayer, branchData.maxLayer);
                maxLane = Math.max(maxLane, assignedLane);

                // Assign lane to all nodes in this branch
                branchData.nodes.forEach(node => {
                    node.lane = assignedLane;
                });
            });

            const laneCounter = maxLane + 1;

            // Calculate actual positions with extra spacing at branch points
            // First, identify which layers have branch points (nodes branching from different branch)
            const branchPointLayers = new Set();
            nodeMap.forEach(node => {
                if (node.parentId !== null) {
                    const parent = nodeMap.get(node.parentId);
                    if (parent && parent.branch !== node.branch) {
                        // Mark this layer as having a branch point
                        branchPointLayers.add(node.layer);
                    }
                }
            });

            // Calculate cumulative extra spacing per layer
            // Extra spacing should be added BEFORE the layer with branch point
            const cumulativeSpacing = [];
            let cumulative = 0;
            for (let layer = 0; layer <= maxLayer; layer++) {
                // Add spacing before this layer if it has branch points
                if (branchPointLayers.has(layer)) {
                    cumulative += config.branchPointSpacing;
                }
                cumulativeSpacing[layer] = cumulative;
            }

            // Assign positions
            nodeMap.forEach(node => {
                node.x = config.padding.left + node.lane * config.horizontalSpacing;
                node.y = config.padding.top +
                         node.layer * config.verticalSpacing +
                         cumulativeSpacing[node.layer];
            });

            graph.nodes = Array.from(nodeMap.values());
            graph.width = config.padding.left + config.padding.right +
                          (laneCounter) * config.horizontalSpacing;

            // Calculate actual height based on final node positions
            const maxY = Math.max(...graph.nodes.map(n => n.y));
            graph.height = maxY + config.padding.bottom;

            return graph;
        }

        // Store full graph globally
        let fullGraph = null;
        let isCollapsed = false;

        // Identify important nodes (heads and branch points)
        function getImportantNodes(graph) {
            const important = new Set();

            graph.nodes.forEach(node => {
                // Root node is always important
                if (node.parentId === null) {
                    important.add(node.id);
                    return;
                }

                // Head nodes (no children or all children in same branch)
                if (node.children.length === 0) {
                    important.add(node.id);
                    return;
                }

                // Branch point nodes (has children in different branches)
                const childBranches = new Set();
                node.children.forEach(childId => {
                    const child = graph.nodes.find(n => n.id === childId);
                    if (child) {
                        childBranches.add(child.branch);
                    }
                });

                if (childBranches.size > 1 || !childBranches.has(node.branch)) {
                    important.add(node.id);
                }
            });

            return important;
        }

        // Create collapsed graph
        function createCollapsedGraph(graph) {
            const important = getImportantNodes(graph);
            const nodeMap = new Map(graph.nodes.map(n => [n.id, n]));

            // Build visible nodes and collapsed ranges
            const newNodes = [];
            const newEdges = [];
            let collapsedIdCounter = 100000; // Use high IDs for collapsed nodes

            // Find sequences of hidden nodes between important nodes
            function findHiddenSequence(startId, endId) {
                const sequence = [];
                let currentId = endId;

                while (currentId !== null && currentId !== startId) {
                    const node = nodeMap.get(currentId);
                    if (!node) break;

                    if (!important.has(currentId)) {
                        sequence.unshift(node);
                    }
                    currentId = node.parentId;
                }

                return sequence;
            }

            // Process each important node
            const sortedImportant = Array.from(important).sort((a, b) => {
                const nodeA = nodeMap.get(a);
                const nodeB = nodeMap.get(b);
                return nodeA.layer - nodeB.layer;
            });

            sortedImportant.forEach(nodeId => {
                const node = nodeMap.get(nodeId);
                newNodes.push(node);

                if (node.parentId !== null) {
                    // Find the nearest visible ancestor
                    let ancestorId = node.parentId;
                    const hiddenNodes = [];

                    while (ancestorId !== null && !important.has(ancestorId)) {
                        const ancestor = nodeMap.get(ancestorId);
                        if (!ancestor) break;
                        hiddenNodes.unshift(ancestor);
                        ancestorId = ancestor.parentId;
                    }

                    if (ancestorId !== null) {
                        if (hiddenNodes.length > 1) {
                            // Create a collapsed node only if there are 2+ hidden nodes
                            const firstHidden = hiddenNodes[0];
                            const lastHidden = hiddenNodes[hiddenNodes.length - 1];

                            const collapsedNode = {
                                id: collapsedIdCounter++,
                                isCollapsed: true,
                                collapsedRange: {
                                    start: firstHidden.id,
                                    end: lastHidden.id,
                                    count: hiddenNodes.length
                                },
                                branch: node.branch,
                                parentId: ancestorId,
                                children: [node.id],
                                layer: firstHidden.layer + Math.floor(hiddenNodes.length / 2),
                                lane: node.lane,
                                x: node.x,
                                y: (nodeMap.get(ancestorId).y + node.y) / 2
                            };

                            newNodes.push(collapsedNode);
                            newEdges.push({ from: ancestorId, to: collapsedNode.id });
                            newEdges.push({ from: collapsedNode.id, to: node.id });
                        } else if (hiddenNodes.length === 1) {
                            // Show single hidden node normally (don't hide it)
                            const singleNode = hiddenNodes[0];
                            newNodes.push(singleNode);
                            newEdges.push({ from: ancestorId, to: singleNode.id });
                            newEdges.push({ from: singleNode.id, to: node.id });
                        } else {
                            // No hidden nodes - connect directly
                            newEdges.push({ from: ancestorId, to: node.id });
                        }
                    }
                }
            });

            return {
                ...graph,
                nodes: newNodes,
                edges: newEdges
            };
        }

        // Render the graph
        function renderGraph(graph) {
            const svg = document.getElementById('graph');
            svg.setAttribute('width', graph.width);
            svg.setAttribute('height', graph.height);
            svg.innerHTML = '';

            // Draw edges with curves
            graph.edges.forEach(edge => {
                const from = graph.nodes.find(n => n.id === edge.from);
                const to = graph.nodes.find(n => n.id === edge.to);

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'edge');

                // Create curved path
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const midY = from.y + dy / 2;

                // Cubic bezier curve for smooth connection
                const pathData = `M ${from.x} ${from.y} C ${from.x} ${midY}, ${to.x} ${midY}, ${to.x} ${to.y}`;
                path.setAttribute('d', pathData);

                // Different style for branch creation
                if (from.branch !== to.branch) {
                    path.setAttribute('stroke-dasharray', '5,5');
                    path.setAttribute('stroke', testData.branches[to.branch].color);
                    path.setAttribute('opacity', '0.6');
                }

                svg.appendChild(path);
            });

            // Draw nodes
            graph.nodes.forEach(node => {
                if (node.isCollapsed) {
                    // Render collapsed node (two overlapping circles)
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'collapsed-node');
                    g.setAttribute('data-id', node.id);

                    // First circle (background)
                    const circle1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle1.setAttribute('cx', node.x);
                    circle1.setAttribute('cy', node.y - 3);
                    circle1.setAttribute('r', config.nodeRadius);
                    circle1.setAttribute('fill', testData.branches[node.branch].color);
                    circle1.setAttribute('stroke', '#d4d4d4');
                    circle1.setAttribute('stroke-width', '2');
                    circle1.setAttribute('opacity', '0.6');

                    // Second circle (foreground)
                    const circle2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle2.setAttribute('cx', node.x);
                    circle2.setAttribute('cy', node.y + 3);
                    circle2.setAttribute('r', config.nodeRadius);
                    circle2.setAttribute('fill', testData.branches[node.branch].color);
                    circle2.setAttribute('stroke', '#d4d4d4');
                    circle2.setAttribute('stroke-width', '2');

                    // Label showing range
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', node.x + config.nodeRadius + 9);
                    text.setAttribute('y', node.y + 4);
                    text.setAttribute('text-anchor', 'start');
                    text.setAttribute('fill', '#858585');
                    text.setAttribute('font-size', '10px');
                    text.setAttribute('font-style', 'italic');
                    text.textContent = `v${node.collapsedRange.start}..v${node.collapsedRange.end}`;

                    g.appendChild(circle1);
                    g.appendChild(circle2);
                    g.appendChild(text);
                    g.onclick = () => showCollapsedDetails(node);

                    svg.appendChild(g);
                } else {
                    // Render normal node
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'version-node');
                    g.setAttribute('data-id', node.id);
                    g.style.cursor = 'pointer';

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', node.x);
                    circle.setAttribute('cy', node.y);
                    circle.setAttribute('r', config.nodeRadius);
                    circle.setAttribute('fill', testData.branches[node.branch].color);
                    circle.setAttribute('stroke', '#d4d4d4');
                    circle.setAttribute('stroke-width', '2');

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', node.x + config.nodeRadius + 6);
                    text.setAttribute('y', node.y + 4);
                    text.setAttribute('text-anchor', 'start');
                    text.setAttribute('fill', '#d4d4d4');
                    text.setAttribute('font-size', '11px');
                    text.textContent = `v${node.id}`;

                    g.appendChild(circle);
                    g.appendChild(text);
                    g.onclick = () => showVersionDetails(node);

                    svg.appendChild(g);
                }
            });
        }

        // Show version details in modal
        function showVersionDetails(node) {
            const modal = document.getElementById('versionModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');

            modalTitle.textContent = `Version ${node.id}`;

            const branch = testData.branches[node.branch];
            const parent = node.parentId !== null ?
                testData.versions.find(v => v.id === node.parentId) : null;

            modalBody.innerHTML = `
                <div class="modal-section">
                    <div class="modal-label">Branch</div>
                    <div class="modal-value">
                        <span class="version-badge" style="background: ${branch.color}20; color: ${branch.color}; border: 1px solid ${branch.color}">
                            ${branch.name}
                        </span>
                    </div>
                </div>
                <div class="modal-section">
                    <div class="modal-label">Version ID</div>
                    <div class="modal-value">${node.id}</div>
                </div>
                <div class="modal-section">
                    <div class="modal-label">Parent Version</div>
                    <div class="modal-value">${parent ? `v${parent.id} (${parent.branch})` : 'None (root)'}</div>
                </div>
                <div class="modal-section">
                    <div class="modal-label">Layer</div>
                    <div class="modal-value">${node.layer}</div>
                </div>
                <div class="modal-section">
                    <div class="modal-label">Children</div>
                    <div class="modal-value">${node.children.length > 0 ? node.children.map(c => `v${c}`).join(', ') : 'None'}</div>
                </div>
                ${parent && parent.branch !== node.branch ? `
                <div class="modal-section">
                    <div class="modal-label">Branch Point</div>
                    <div class="modal-value" style="color: #4ec9b0">Branched from ${parent.branch} at v${parent.id}</div>
                </div>
                ` : ''}
            `;

            modal.classList.add('active');
        }

        // Show collapsed node details in modal
        function showCollapsedDetails(node) {
            const modal = document.getElementById('versionModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');

            modalTitle.textContent = `Collapsed Versions`;

            const branch = testData.branches[node.branch];

            modalBody.innerHTML = `
                <div class="modal-section">
                    <div class="modal-label">Branch</div>
                    <div class="modal-value">
                        <span class="version-badge" style="background: ${branch.color}20; color: ${branch.color}; border: 1px solid ${branch.color}">
                            ${branch.name}
                        </span>
                    </div>
                </div>
                <div class="modal-section">
                    <div class="modal-label">Version Range</div>
                    <div class="modal-value">v${node.collapsedRange.start} to v${node.collapsedRange.end}</div>
                </div>
                <div class="modal-section">
                    <div class="modal-label">Collapsed Versions</div>
                    <div class="modal-value">${node.collapsedRange.count} version(s) hidden</div>
                </div>
                <div class="modal-section">
                    <div class="modal-label">Info</div>
                    <div class="modal-value" style="color: #858585; font-size: 12px;">
                        These are intermediate versions between branch points. Uncheck "Collapse" to see all versions.
                    </div>
                </div>
            `;

            modal.classList.add('active');
        }

        function closeModal() {
            document.getElementById('versionModal').classList.remove('active');
        }

        // Render legend
        function renderLegend() {
            const legendItems = document.getElementById('legendItems');
            Object.values(testData.branches).forEach(branch => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${branch.color}"></div>
                    <span>${branch.name}</span>
                `;
                legendItems.appendChild(item);
            });
        }

        // Toggle collapse mode
        function toggleCollapse() {
            isCollapsed = document.getElementById('collapseToggle').checked;

            if (isCollapsed) {
                const collapsed = createCollapsedGraph(fullGraph);
                renderGraph(collapsed);
            } else {
                renderGraph(fullGraph);
            }
        }

        // Close modal on background click
        document.getElementById('versionModal').addEventListener('click', (e) => {
            if (e.target.id === 'versionModal') {
                closeModal();
            }
        });

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            fullGraph = buildGraph(testData);
            renderGraph(fullGraph);
            renderLegend();
        });
    </script>
</body>
</html>
